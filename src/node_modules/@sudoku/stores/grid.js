import { BOX_SIZE, SUDOKU_SIZE } from '@sudoku/constants';
import { decodeSencode, encodeSudoku } from '@sudoku/sencode';
import { generateSudoku, solveSudoku } from '@sudoku/sudoku';
import { derived, writable } from 'svelte/store';
import { hints } from './hints';

export const solutionGrid = writable(null);

function createGrid() {
	const grid = writable([
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
	]);

	function setSolutionFromGrid(gridData) {
		const solved = solveSudoku(gridData);
		solutionGrid.set(solved ? solved : null);
	}

	return {
		subscribe: grid.subscribe,

		setGrid: (newGrid) => grid.set(newGrid),

		generate(difficulty) {
			const newGrid = generateSudoku(difficulty);
			grid.set(newGrid);
			setSolutionFromGrid(newGrid);
		},

		decodeSencode(sencode) {
			const newGrid = decodeSencode(sencode);
			grid.set(newGrid);
			setSolutionFromGrid(newGrid);
		},

		get(gridStore, x, y) {
			return gridStore[y][x];
		},

		getSencode(gridStore) {
			return encodeSudoku(gridStore);
		},
	};
}

export const grid = createGrid();


// 历史记录栈
export let userGridHistory = [];
export let userGridFuture = [];
export let candidatesHistory = [];
export let candidatesFuture = [];


function deepCloneGrid(grid) {
	return grid.map(row => [...row]);
}

function deepCloneCandidates(candidates) {
	return JSON.parse(JSON.stringify(candidates));
}

function createUserGrid() {
	const userGrid = writable([
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
	]);

	grid.subscribe($grid => {
		let newGrid = [];

		for (let y = 0; y < SUDOKU_SIZE; y++) {
			newGrid[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				newGrid[y][x] = $grid[y][x];
			}
		}

		userGrid.set(newGrid);
	});

	return {
		subscribe: userGrid.subscribe,

		setGrid: (newGrid) => userGrid.set(newGrid),

		set: (pos, value, candidatesStore) => {
			userGrid.update($userGrid => {
				userGridHistory.push(deepCloneGrid($userGrid));
				userGridFuture = [];
				if (candidatesStore) {
					candidatesStore.update($candidates => {
						candidatesHistory.push(deepCloneCandidates($candidates));
						candidatesFuture = [];
						return $candidates;
					});
				}
				$userGrid[pos.y][pos.x] = value;
				return $userGrid;
			});
		},

		applyHint: (pos, candidatesStore) => {
			hints.useHint();
			userGrid.update($userGrid => {
				userGridHistory.push(deepCloneGrid($userGrid));
				userGridFuture = [];
				if (candidatesStore) {
					candidatesStore.update($candidates => {
						candidatesHistory.push(deepCloneCandidates($candidates));
						candidatesFuture = [];
						return $candidates;
					});
				}
				const solvedSudoku = solveSudoku($userGrid);
				$userGrid[pos.y][pos.x] = solvedSudoku[pos.y][pos.x];
				return $userGrid;
			});
		},

		undo: (candidatesStore) => {
			userGrid.update($userGrid => {
				if (userGridHistory.length > 0) {
					userGridFuture.push(deepCloneGrid($userGrid));
					const prev = userGridHistory.pop();
					if (candidatesStore && candidatesHistory.length > 0) {
						candidatesStore.set(deepCloneCandidates(candidatesHistory.pop()));
						candidatesFuture.push(deepCloneCandidates($candidates));
					}
					return prev;
				}
				return $userGrid;
			});
		},

		redo: (candidatesStore) => {
			userGrid.update($userGrid => {
				if (userGridFuture.length > 0) {
					userGridHistory.push(deepCloneGrid($userGrid));
					const next = userGridFuture.pop();
					if (candidatesStore && candidatesFuture.length > 0) {
						candidatesStore.set(deepCloneCandidates(candidatesFuture.pop()));
						candidatesHistory.push(deepCloneCandidates($candidates));
					}
					return next;
				}
				return $userGrid;
			});
		},
	};
}

export const userGrid = createUserGrid();

export const invalidCells = derived(userGrid, $userGrid => {
	const _invalidCells = [];

	const addInvalid = (x, y) => {
		const xy = x + ',' + y;
		if (!_invalidCells.includes(xy)) _invalidCells.push(xy);
	};

	for (let y = 0; y < SUDOKU_SIZE; y++) {
		for (let x = 0; x < SUDOKU_SIZE; x++) {

			const value = $userGrid[y][x];

			if (value) {
				for (let i = 0; i < SUDOKU_SIZE; i++) {
					// Check the row
					if (i !== x && $userGrid[y][i] === value) {
						addInvalid(x, y);
					}

					// Check the column
					if (i !== y && $userGrid[i][x] === value) {
						addInvalid(x, i);
					}
				}

				// Check the box
				const startY = Math.floor(y / BOX_SIZE) * BOX_SIZE;
				const endY = startY + BOX_SIZE;
				const startX = Math.floor(x / BOX_SIZE) * BOX_SIZE;
				const endX = startX + BOX_SIZE;
				for (let row = startY; row < endY; row++) {
					for (let col = startX; col < endX; col++) {
						if (row !== y && col !== x && $userGrid[row][col] === value) {
							addInvalid(col, row);
						}
					}
				}
			}

		}
	}

	return _invalidCells;
}, []);

// 新增：用户填错的格子高亮
export const wrongCells = derived([userGrid, solutionGrid], ([$userGrid, $solutionGrid]) => {
	if (!$solutionGrid) return [];
	const wrong = [];
	for (let y = 0; y < SUDOKU_SIZE; y++) {
		for (let x = 0; x < SUDOKU_SIZE; x++) {
			if ($userGrid[y][x] !== 0 && $userGrid[y][x] !== $solutionGrid[y][x]) {
				wrong.push(x + ',' + y);
			}
		}
	}
	return wrong;
}, []);